Index: Manager/src/main/java/Manager.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//import com.amazonaws.services.sqs.AmazonSQSClientBuilder;\n//import com.amazonaws.services.sqs.model.AmazonSQSException;\n//import com.amazonaws.services.sqs.model.SendMessageBatchRequest;\n//import com.amazonaws.services.sqs.model.SendMessageBatchRequestEntry;\n\n//import API.AWS;\nimport software.amazon.awssdk.services.ec2.model.Instance;\nimport software.amazon.awssdk.services.s3.model.S3Object;\nimport software.amazon.awssdk.services.sqs.model.Message;\n\nimport java.io.*;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\n\npublic class Manager {\n    final static AWS aws = AWS.getInstance();\n    private static final int MAX_WORKERS = 19;\n    private static volatile boolean terminate = false;\n    private static String inputQueueUrl;\n    private static String workersQueueUrl = aws.createQueue(\"workersQueue\");\n    private static String responseQueueUrl = aws.createQueue(\"responseQueue\");\n    private static HashMap<String, Integer> localAppMap = new HashMap<>();\n\npublic static void main(String[] args) {  \n    while (!terminate){\n\n        //processing input files\n        inputQueueUrl = aws.getQueueUrl(\"inputQueue\");\n        List<Message> inputList = aws.receiveMessages(inputQueueUrl);\n        for (Message input : inputList) {\n            //processing input files\n            processInputFile(input);\n            aws.deleteMessage(inputQueueUrl, input); // Correct method for receipt handle\n        }\n        //processing workers output files\n        processResponseMessage();\n        \n    }   \n}\n\npublic static void processInputFile(Message inputFile){\n    if(isTeminateMessage(inputFile.body())){\n        terminate();\n    } \n    else {\n        String inputFileId = inputFile.messageId();\n        String[] messageParts = inputFile.body().split(\"\\t\");\n        String keyPath = messageParts[0];\n        int tasksPerWorker = Integer.valueOf(messageParts[1]);\n        String filePath = System.getProperty(\"user.dir\") + File.separator + \"input-files\" + File.separator + inputFileId; //locally on EC2\n        File file = new File(filePath);\n        try {\n            // Attempt to create the file\n            if (file.createNewFile()) {\n                System.out.println(\"File created: \" + file.getAbsolutePath());\n            } else {\n                System.out.println(\"File already exists.\");\n            }\n        } catch (IOException e) {\n            // Handle potential IO exceptions\n            System.out.println(\"An error occurred while creating the file.\");\n            e.printStackTrace();\n        }\n        aws.downloadFileFromS3(keyPath, file);//download file from s3 to ec2\n        List<String> urlsAndOperations = parseInputFile(filePath, inputFileId); // read URLs and operations from the input file\n        localAppMap.put(inputFileId, urlsAndOperations.size());\n        manageWorkers(urlsAndOperations.size(), tasksPerWorker); // create correct amount of workers \n\n        // send url and ops to worker queue\n        for (String msg : urlsAndOperations) {\n            aws.sendMessage(workersQueueUrl, msg);\n        }\n        // aws.sendMessageBatches(workersQueueUrl, urlsAndOperations);\n    }\n}\n\nprivate static List<String> parseInputFile(String filePath, String inputFileId) {\n    List<String> urlsAndOperations = new ArrayList<>();\n    try (BufferedReader reader = new BufferedReader(new FileReader(filePath))) {\n        String line;\n        while ((line = reader.readLine()) != null) {\n            urlsAndOperations.add(line.trim()+ \"\\t\" + inputFileId);\n        }\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n    return urlsAndOperations;\n}\n\n\nprivate static void manageWorkers(int messageCount, int tasksPerWorker) {\n    int requiredWorkers = Math.min((messageCount + tasksPerWorker - 1) / tasksPerWorker, MAX_WORKERS);\n\n    List<Instance> runningWorkers = null;  // Get the count of currently running workers\n    try {\n        runningWorkers = aws.getAllInstancesWithLabel(AWS.Label.Worker);\n    } catch (InterruptedException e) {\n        throw new RuntimeException(e);\n    }\n    int currentWorkerCount = runningWorkers.size();\n\n    if (currentWorkerCount < requiredWorkers) {\n        int workersToStart = requiredWorkers - currentWorkerCount;\n        System.out.printf(\"Starting %d new workers...\\n\", workersToStart);\n        // String script = \"#!/bin/bash\\n\" +\n        // \"exec > /var/log/user-data.log 2>&1\\n\" +\n        // \"java -jar /home/ec2-user/manager.jar\\n\"; //change it to worker\n\n        String script = \"#!/bin/bash\\n\" +\n        \"echo Manager jar running\\n\" +\n        \"echo s3://\" + aws.getBucketName() + \"/\" + aws.managerJarKey + \"\\n\" +\n        \"mkdir ManagerFiles\\n\" +\n        \"aws s3 cp s3://\" + aws.getBucketName() + \"/\" + aws.managerJarKey + \" ./ManagerFiles/\" + aws.managerJarName + \"\\n\" +\n        \"echo manager copy the jar from s3\\n\" +\n        \"java -jar /ManagerFiles/\" + aws.managerJarName + \"\\n\";\n        aws.createEC2(script, \"Worker\", workersToStart);\n   }\n}\n\nprivate static void processResponseMessage(){\n    List<Message> responseList = aws.receiveMessages(responseQueueUrl);\n    for(Message response : responseList) {\n        String messageBody = response.body();\n        System.out.println(\"Received response: \" + messageBody);\n\n        // Split the response message by tab separator (\\t)\n        String[] parts = messageBody.split(\"\\t\");\n\n        // Ensure that the response message has the correct number of parts\n        if (parts.length == 4) {\n            String operation = parts[0];\n            String pdfUrl = parts[1];\n            String s3ResultsPath = parts[2];\n            String fileId = parts[3];\n\n            // Generate a unique key for the individual response\n            String responseFileKey = \"responses/\" + fileId + \"/\" + response.messageId() + \".txt\";\n            String responseData = String.format(\"%s\\t%s\\t%s\", operation, pdfUrl, s3ResultsPath);\n            File tempFile = createTempFile(responseData);\n            // Upload the response to S3\n            try {\n                aws.uploadFileToS3(responseFileKey, tempFile);\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n            tempFile.delete();\n            \n            int cur = localAppMap.get(fileId) - 1;\n            if (cur == 0) {\n                String summaryFile = generateSummaryFile(fileId);\n                System.out.println(\"Summary file created: \" + summaryFile);\n                int summaryNum = (fileId.hashCode() & Integer.MAX_VALUE) % aws.getSummaryLimit() + 1;\n                String summaryQueueUrl = aws.getQueueUrl(\"summaryQueue_\" + summaryNum); \n                aws.sendMessageWithId(summaryQueueUrl, summaryFile, fileId);\n                System.out.println(\"Summary file sent to: summaryQueue_\" + summaryNum + \" with  fileId: \" + fileId);\n            }\n            localAppMap.put(fileId,cur);\n        } \n\n        else {\n            System.err.println(\"Invalid message format: \" + messageBody);\n        }\n}\n}\n\nprivate static File createTempFile(String content) {\n    File tempFile = null;\n    try {\n        tempFile = File.createTempFile(\"response\", \".txt\"); // Create a temporary file\n        try (BufferedWriter writer = new BufferedWriter(new FileWriter(tempFile))) { // Write the content to the temporary file\n            writer.write(content);\n        }\n    } catch (IOException e) {\n        e.printStackTrace();\n        throw new RuntimeException(\"Failed to create temporary file for upload\");\n    }\n    return tempFile;\n}\n\nprivate static String generateSummaryFile(String inputFileId) {\n    String responseDirKey = \"responses/\" + inputFileId + \"/\";\n    String summaryFileKey = \"summaries/\" + inputFileId + \".txt\";\n\n    // List all response files in S3\n    List<S3Object> responseFiles = aws.listFilesInS3(responseDirKey);\n\n    // Combine content into a summary file\n    StringBuilder summaryContent = new StringBuilder();\n    for (S3Object responseFile : responseFiles) {\n\n        // Download the response file content from S3 to a local file\n        String filePath = System.getProperty(\"user.dir\") + File.separator + \"output-files\" + File.separator + inputFileId; //locally on EC2\n        File localFile = new File(filePath);\n        try {\n            // Attempt to create the file\n            if (localFile.createNewFile()) {\n                System.out.println(\"File created: \" + localFile.getAbsolutePath());\n            } else {\n                System.out.println(\"File already exists.\");\n            }\n        } catch (IOException e) {\n            // Handle potential IO exceptions\n            System.out.println(\"An error occurred while creating the file.\");\n            e.printStackTrace();\n        }\n        aws.downloadFileFromS3(responseFile.key(),localFile);\n        String fileContent = readFileContent(localFile);\n        summaryContent.append(fileContent).append(System.lineSeparator());\n        localFile.delete();\n    }\n    // Create a new file to store the summary\n    File summaryFile = new File(System.getProperty(\"user.dir\") + File.separator + \"output-files\" + File.separator + inputFileId + \"-summary.txt\");\n    try {\n        if (!summaryFile.exists()) {\n            summaryFile.createNewFile();\n        }\n\n        // Write the summary content to the summary file\n        try (BufferedWriter writer = new BufferedWriter(new FileWriter(summaryFile))) {\n            writer.write(summaryContent.toString());\n        }\n    } catch (IOException e) {\n        System.out.println(\"An error occurred while creating the summary file.\");\n        e.printStackTrace();\n    }\n\n    // Upload the summary file to S3\n    try {\n        return aws.uploadFileToS3(summaryFileKey, summaryFile);\n    } catch (Exception e) {\n        throw new RuntimeException(e);\n    }\n}\n\nprivate static String readFileContent(File file) {\n    StringBuilder content = new StringBuilder();\n    try (BufferedReader reader = new BufferedReader(new FileReader(file))) {\n        String line;\n        while ((line = reader.readLine()) != null) {\n            content.append(line).append(System.lineSeparator());\n        }\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n    return content.toString();\n}\n\npublic static void terminate() {\n    while (!(localAppMap.values().stream().allMatch(count -> count == 0))) { //not all job completed\n        try {\n            Thread.sleep(5000); // Poll every 5 seconds\n            System.out.println(\"Waiting for all jobs to complete...\");\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n    generateAllPendingSummaries(); // Create response messages for any completed jobs, if needed\n    terminateAllWorkers();\n    List<String> managerIds = null;\n    try {\n        managerIds = aws.getAllInstanceIdsWithLabel(AWS.Label.Manager);\n    } catch (InterruptedException e) {\n        throw new RuntimeException(e);\n    }\n    aws.terminateInstance(managerIds.get(0)); //terminate the Manager\n}\n\nprivate static void generateAllPendingSummaries() {\n    System.out.println(\"Generating pending summaries...\");\n    for (String inputFileId : localAppMap.keySet()) {\n        if (localAppMap.get(inputFileId) == 0) {\n            generateSummaryFile(inputFileId); // Generate the summary for completed jobs\n        }\n    }\n}\n\nprivate static void terminateAllWorkers() {\n    System.out.println(\"Terminating all worker instances...\");\n    List<String> workerIds = null;\n    try {\n        workerIds = aws.getAllInstanceIdsWithLabel(AWS.Label.Worker);\n    } catch (InterruptedException e) {\n        throw new RuntimeException(e);\n    }\n    for (String id : workerIds) {\n        aws.terminateInstance(id);\n        System.out.println(\"Terminated worker instance: \" + id);\n    }\n}\n    //String awsAccessKey = System.getenv(\"AWS_ACCESS_KEY\");\n    //String awsSecretKey = System.getenv(\"AWS_SECRET_KEY\");\n    //String sessionToken = System.getenv(\"AWS_SESSION_TOKEN\");\n\npublic static boolean isTeminateMessage(String messageBody){\n    if (messageBody.equals(\"terminate\")){\n        terminate = true;\n        System.out.println(\"Manager got terminate message\");\n        return true;\n    }\n    return false;\n}\n\n}\n\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Manager/src/main/java/Manager.java b/Manager/src/main/java/Manager.java
--- a/Manager/src/main/java/Manager.java	(revision cc9a4560f3186c9a240bf6a014f37c4839206ddb)
+++ b/Manager/src/main/java/Manager.java	(date 1733240664998)
@@ -288,9 +288,6 @@
         System.out.println("Terminated worker instance: " + id);
     }
 }
-    //String awsAccessKey = System.getenv("AWS_ACCESS_KEY");
-    //String awsSecretKey = System.getenv("AWS_SECRET_KEY");
-    //String sessionToken = System.getenv("AWS_SESSION_TOKEN");
 
 public static boolean isTeminateMessage(String messageBody){
     if (messageBody.equals("terminate")){
