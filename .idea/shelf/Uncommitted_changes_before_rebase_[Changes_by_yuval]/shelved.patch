Index: Local-App/src/main/java/LocalApplication.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import software.amazon.awssdk.services.ec2.model.Instance;\nimport software.amazon.awssdk.services.sqs.model.*;\n\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.time.Instant;\n\n\npublic class LocalApplication {\n\n    final static AWS aws = AWS.getInstance();\n    private static String inputQueueUrl;\n    private static String summaryQueueUrl;\n    private static String inFilePath;\n    private static String outFilePath;\n    private static Message summary = null;\n\n\n    public static void main(String[] args) {// args = [inFilePath, outFilePath, tasksPerWorker, -t (terminate, optional)]\n        args = new String[]{\"/Users/hagarsamimigolan/Downloads/input-sample-1 (1).txt\",\n                \"/Users/hagarsamimigolan/GitProject/PDF-Document-Conversion-in-the-Cloud/Local-App/target/outPutFile\", \"10\"};\n        if (args.length < 3) {\n            System.out.println(\"Usage: LocalApplication <inputFilePath> <outputFilePath> [tasksPerWorker] [-t]\");\n            return;\n        }\n\n        inFilePath = args[0];\n        outFilePath = args[1]; \n        String tasksPerWorker = args[2];\n        boolean terminate = (args.length == 4 && args[3].equals(\"-t\"));\n        \n        String timestamp = String.valueOf(Instant.now().toEpochMilli());\n        String uniqueId = timestamp + \"-\" + new File(inFilePath).getName();\n        String keyPath = \"input-files/\" + uniqueId;\n        \n        try {\n            setup();\n\n            // upload input file to S3\n            aws.uploadFileToS3(keyPath, new File(inFilePath)); \n\n            // send message to inputQueue\n            String messageBody = String.format(\"%s\\t%s\", keyPath, tasksPerWorker);\n            String msgId = aws.sendMessage(inputQueueUrl, messageBody); \n\n            // \"subscribe\" to correct summary queue\n            int summaryNum = (msgId.hashCode() & Integer.MAX_VALUE) % aws.getSummaryLimit() + 1;\n            summaryQueueUrl = aws.getQueueUrl(\"summaryQueue_\" + summaryNum); \n            while (summary != null) {\n                summary = aws.receiveMessageWithId(summaryQueueUrl, msgId);\n            }\n\n            // download summary from s3\n            File summaryFile = new File(\"local-summary.txt\");\n            aws.downloadFileFromS3(summary, summaryFile);\n\n            // creates html output file\n            summaryToHTML(summaryFile);\n\n            // Check if we need to send a termination message\n            if (terminate) {\n                aws.sendMessage(inputQueueUrl, \"terminate\"); // Send termination message to the queue\n                System.out.println(\"Terminate message sent.\");\n\n            // waits to get message back in sqs queue\n            // create html file representing the results \n            // how does terminate look \n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    \n\n    //Create Buckets, Create Queues, Upload JARs to S3\n    private static void setup() {\n        ArrayList<Instance> arr = aws.getAllInstancesWithLabel(aws.Label.Manager);\n        if (arr.isEmpty) { // if manager is not active\n            aws.createBucketIfNotExists(\"yh-bucket\");\n            inputQueueUrl = aws.createQueue(\"inputQueue\");\n            for (int i = 1; i <= aws.getSummaryLimit(); i++) {\n                String name = \"summaryQueue_\" + i;\n                aws.createQueue(name);\n            }\n            String script = \"#!/bin/bash\\n\" +\n                \"exec > /var/log/user-data.log 2>&1\\n\" +\n                \"java -jar /home/ec2-user/manager.jar\\n\";\n            aws.createEC2(script, \"Manager\", 1); // create manager ec2\n        }\n    }\n\n    private static void createEC2() {\n        String ec2Script = \"#!/bin/bash\\n\" +\n                \"echo Hello World\\n\";\n        String managerInstanceID = aws.createEC2(ec2Script, \"thisIsJustAString\", 1);\n    }\n\n  \n\n    private static void summaryToHTML(File summaryFile) {\n        File htmlOutputFile = new File(outFilePath);\n        try (PrintWriter writer = new PrintWriter(htmlOutputFile)) {\n            // Read the summary file line by line\n            try (Scanner scanner = new Scanner(summaryFile)) {\n                while (scanner.hasNextLine()) {\n                    String line = scanner.nextLine();\n                    String[] parts = line.split(\"\\t\");\n\n                    if (parts.length < 3) {\n                        writer.println(\"Invalid summary line: \" + line);\n                        continue;\n                    }\n\n                    String operation = parts[0];\n                    String inputFile = parts[1];\n                    String result = parts[2];\n\n                    // Generate HTML line\n                    String htmlLine;\n                    if (result.startsWith(\"http\")) {\n                        // If the result is a valid URL, create links for input and output files\n                        htmlLine = String.format(\"<p>%s: <a href='%s'>%s</a> <a href='%s'>%s</a></p>\",\n                                operation, inputFile, inputFile, result, result);\n                    } else {\n                        // If an exception occurred or the file is not available, show the result as a description\n                        htmlLine = String.format(\"<p>%s: <a href='%s'>%s</a> %s</p>\", operation, inputFile, inputFile, result);\n                    }\n                    writer.println(htmlLine);\n                }\n            }\n            System.out.println(\"HTML output file created at: \" + htmlOutputFile.getAbsolutePath());\n        } catch (Exception e) {\n            System.err.println(\"Error while creating HTML output file: \" + e.getMessage());\n        }\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Local-App/src/main/java/LocalApplication.java b/Local-App/src/main/java/LocalApplication.java
--- a/Local-App/src/main/java/LocalApplication.java	(revision cc9a4560f3186c9a240bf6a014f37c4839206ddb)
+++ b/Local-App/src/main/java/LocalApplication.java	(date 1732997164712)
@@ -3,8 +3,12 @@
 
 
 import java.io.File;
+import java.io.PrintWriter;
 import java.util.ArrayList;
 import java.time.Instant;
+import java.util.List;
+import java.util.Scanner;
+
 
 
 public class LocalApplication {
@@ -36,7 +40,6 @@
         
         try {
             setup();
-
             // upload input file to S3
             aws.uploadFileToS3(keyPath, new File(inFilePath)); 
 
@@ -53,7 +56,7 @@
 
             // download summary from s3
             File summaryFile = new File("local-summary.txt");
-            aws.downloadFileFromS3(summary, summaryFile);
+            aws.downloadFileFromS3(summary.body(), summaryFile);
 
             // creates html output file
             summaryToHTML(summaryFile);
@@ -76,18 +79,23 @@
 
     //Create Buckets, Create Queues, Upload JARs to S3
     private static void setup() {
-        ArrayList<Instance> arr = aws.getAllInstancesWithLabel(aws.Label.Manager);
-        if (arr.isEmpty) { // if manager is not active
-            aws.createBucketIfNotExists("yh-bucket");
-            inputQueueUrl = aws.createQueue("inputQueue");
-            for (int i = 1; i <= aws.getSummaryLimit(); i++) {
-                String name = "summaryQueue_" + i;
-                aws.createQueue(name);
-            }
-            String script = "#!/bin/bash\n" +
-                "exec > /var/log/user-data.log 2>&1\n" +
-                "java -jar /home/ec2-user/manager.jar\n";
-            aws.createEC2(script, "Manager", 1); // create manager ec2
+        try {
+            List<Instance> list = aws.getAllInstancesWithLabel(AWS.Label.Manager);
+            if (list.isEmpty()) { // if manager is not active
+                aws.createBucketIfNotExists(aws.getBucketName());
+                inputQueueUrl = aws.createQueue("inputQueue");
+                for (int i = 1; i <= aws.getSummaryLimit(); i++) {
+                    String name = "summaryQueue_" + i;
+                    aws.createQueue(name);
+                }
+                String script = "#!/bin/bash\n" +
+                        "exec > /var/log/user-data.log 2>&1\n" +
+                        "java -jar /home/ec2-user/manager.jar\n";
+                aws.createEC2(script, "Manager", 1); // create manager EC2
+            }
+        } catch (InterruptedException e) {
+            System.err.println("Error occurred while retrieving instances: " + e.getMessage());
+            Thread.currentThread().interrupt();
         }
     }
 
Index: Worker/src/main/java/Worker.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//import api.AWS;\nimport org.apache.pdfbox.pdmodel.PDDocument;\nimport org.apache.pdfbox.rendering.PDFRenderer;\nimport org.apache.pdfbox.text.PDFTextStripper;\n\nimport software.amazon.awssdk.services.sqs.model.Message;\n\nimport java.awt.image.BufferedImage;\nimport java.io.*;\nimport java.nio.file.Files;\nimport java.util.List;\nimport javax.imageio.ImageIO;\n\npublic class Worker {\n\n    final static AWS aws = AWS.getInstance();\n\n    public static void main(String[] args) {\n        start();\n    }\n\n\n    public static void start() {\n        while (true) {\n            // Get a message from an SQS queue\n            String workersQueueUrl = aws.getQueueUrl(\"workersQueue\");\n            String responseQueueUrl = aws.getQueueUrl(\"responseQueue\");\n            try {\n                List<Message> messages = aws.receiveMessages(workersQueueUrl);\n                if (messages == null) continue; // No messages, keep polling\n                \n                // Parse the message\n                for (Message m : messages){\n                    String[] parts = m.body().split(\"\\t\");\n                    String operation = parts[0];\n                    String pdfUrl = parts[1];\n                    String fileId = parts[2];\n                \n                    // Download the PDF file and perform operation\n                    File pdfFile = downloadPDF(pdfUrl);\n                    File resultFile = performOperation(operation, pdfFile);\n\n                    // Upload the result to S3   \n                    String s3ResultsPath = \"results\" + File.separator + m.messageId();\n                    String resultS3Url = aws.uploadFileToS3(s3ResultsPath, resultFile);\n                    String responseMessage = String.format(\"%s\\t%s\\t%s\\t%s\", operation, pdfUrl, s3ResultsPath, fileId);\n\n                    // Send success message to the response queue and Remove the processed message from the task queue\n                    aws.sendMessage(responseQueueUrl, responseMessage);\n                    aws.deleteMessage(workersQueueUrl, m);\n\n                    try { // delete local output file in order to handle next message\n                        if (Files.deleteIfExists(pdfFile.toPath())) {\n                            System.out.println(\"File deleted successfully.\");\n                        } else {\n                            System.out.println(\"File did not exist.\");\n                        }\n                    } catch (IOException e) {\n                        System.out.println(\"An error occurred: \" + e.getMessage());\n                    }\n\n                    try { // delete local output file in order to handle next message\n                        if (Files.deleteIfExists(resultFile.toPath())) {\n                            System.out.println(\"File deleted successfully.\");\n                        } else {\n                            System.out.println(\"File did not exist.\");\n                        }\n                    } catch (IOException e) {\n                        System.out.println(\"An error occurred: \" + e.getMessage());\n                    }\n                }\n\n            } catch (Exception e) {\n                e.printStackTrace();\n                aws.sendMessage(responseQueueUrl, \"Error processing task: \" + e.getMessage());\n            }\n        }\n    }\n\n    private File downloadPDF(String pdfUrl) throws IOException {\n        // Create a file to save the downloaded PDF\n        File pdfFile = new File(\"downloaded.pdf\");\n\n        // Download the file and save it to disk\n        try (FileOutputStream fileOutputStream = new FileOutputStream(pdfFile)) {\n            byte[] fileBytes = Request.Get(pdfUrl).execute().returnContent().asBytes();\n            fileOutputStream.write(fileBytes);\n        }\n\n        return pdfFile;\n    }\n\n    private static File performOperation(String operation, File pdfFile) throws IOException {\n        switch (operation) {\n            case \"ToImage\":\n                return convertToImage(pdfFile);\n            case \"ToHTML\":\n                return convertToHTML(pdfFile);\n            case \"ToText\":\n                return convertToText(pdfFile);\n            default:\n                throw new IllegalArgumentException(\"Unknown operation: \" + operation);\n        }\n    }\n\n    // operations \n\n    private static File convertToImage(File pdfFile) throws IOException {\n        PDDocument document = PDDocument.load(pdfFile);\n        PDFRenderer renderer = new PDFRenderer(document);\n        BufferedImage image = renderer.renderImage(0); // renders first page to image \n        File outputFile = new File(\"output.png\"); // creates file (where image will be saved)\n        ImageIO.write(image, \"png\", outputFile); // writes image to file in png format \n        document.close(); // closes PDDoc \n        return outputFile;\n    }\n\n    private static File convertToHTML(File pdfFile) throws IOException {\n        PDDocument document = PDDocument.load(pdfFile);\n        PDFTextStripper stripper = new PDFTextStripper(); // extracts textual content from pdf file\n        String text = stripper.getText(document);\n        File outputFile = new File(\"output.html\"); \n        try (FileWriter writer = new FileWriter(outputFile)) { \n            writer.write(\"<html><body><pre>\" + text + \"</pre></body></html>\");\n        }\n        document.close();\n        return outputFile; \n    }\n\n    private static File convertToText(File pdfFile) throws IOException {\n        PDDocument document = PDDocument.load(pdfFile);\n        PDFTextStripper stripper = new PDFTextStripper();\n        String text = stripper.getText(document);\n        File outputFile = new File(\"output.txt\");\n        try (FileWriter writer = new FileWriter(outputFile)) {\n            writer.write(text);\n        }\n        document.close();\n        return outputFile;\n    }\n\n    // public static void main(){\n    //     File output = convertToImage(\"http://www.bethelnewton.org/images/Passover_Guide_BOOKLET.pdf\");\n        \n    // }\n    \n\n                /* Repeatedly:\n                ▪ Get a message from an SQS queue.\n                ▪ Download the PDF file indicated in the message.\n                ▪ Perform the operation requested on the file.\n                ▪ Upload the resulting output file to S3.\n                ▪ Put a message in an SQS queue indicating the original URL of the PDF, the S3 url of the new\n                image file, and the operation that was performed.\n                ▪ remove the processed message from the SQS queue. */\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Worker/src/main/java/Worker.java b/Worker/src/main/java/Worker.java
--- a/Worker/src/main/java/Worker.java	(revision cc9a4560f3186c9a240bf6a014f37c4839206ddb)
+++ b/Worker/src/main/java/Worker.java	(date 1732996973995)
@@ -10,6 +10,11 @@
 import java.nio.file.Files;
 import java.util.List;
 import javax.imageio.ImageIO;
+import java.net.URI;
+import java.net.http.HttpClient;
+import java.net.http.HttpRequest;
+import java.net.http.HttpResponse;
+import java.nio.file.Path;
 
 public class Worker {
 
@@ -77,17 +82,15 @@
         }
     }
 
-    private File downloadPDF(String pdfUrl) throws IOException {
-        // Create a file to save the downloaded PDF
-        File pdfFile = new File("downloaded.pdf");
-
-        // Download the file and save it to disk
-        try (FileOutputStream fileOutputStream = new FileOutputStream(pdfFile)) {
-            byte[] fileBytes = Request.Get(pdfUrl).execute().returnContent().asBytes();
-            fileOutputStream.write(fileBytes);
-        }
-
-        return pdfFile;
+    private static File downloadPDF(String pdfUrl) throws IOException, InterruptedException {
+        Path pdfPath = Path.of("downloaded.pdf");
+        HttpClient httpClient = HttpClient.newHttpClient();
+        HttpRequest request = HttpRequest.newBuilder()
+                .uri(URI.create(pdfUrl))
+                .GET()
+                .build();
+        httpClient.send(request, HttpResponse.BodyHandlers.ofFile(pdfPath));
+        return pdfPath.toFile();
     }
 
     private static File performOperation(String operation, File pdfFile) throws IOException {
Index: Local-App/src/main/java/AWS.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\nimport software.amazon.awssdk.core.ResponseBytes;\nimport software.amazon.awssdk.core.pagination.sync.SdkIterable;\nimport software.amazon.awssdk.regions.Region;\nimport software.amazon.awssdk.services.ec2.Ec2Client;\nimport software.amazon.awssdk.services.ec2.model.Tag;\nimport software.amazon.awssdk.services.ec2.model.*;\nimport software.amazon.awssdk.services.s3.S3Client;\nimport software.amazon.awssdk.services.s3.model.*;\nimport software.amazon.awssdk.services.s3.paginators.ListObjectsV2Iterable;\nimport software.amazon.awssdk.services.sqs.SqsClient;\nimport software.amazon.awssdk.services.sqs.model.*;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.util.*;\n\npublic class AWS {\n\n    public final String IMAGE_AMI = \"ami-08902199a8aa0bc09\";\n    public Region region1 = Region.US_WEST_2;\n    public Region region2 = Region.US_EAST_1;\n    private final S3Client s3;\n    private final SqsClient sqs;\n    private final Ec2Client ec2;\n    private final String bucketName;\n    private static AWS instance = null;\n    // private final int regionLim = 9;\n\n    private final int summaryLimit = 10;\n\n\n    private AWS() {\n        s3 = S3Client.builder().region(region1).build();\n        sqs = SqsClient.builder().region(region1).build();\n        ec2 = Ec2Client.builder().region(region1).build();\n        bucketName = \"yuval-hagar-best-bucket\";\n    }\n\n    public static AWS getInstance() {\n        if (instance == null) {\n            instance = new AWS();\n        }\n        return instance;\n    }\n\n\n    //////////////////////////////////////////  EC2\n\n    // EC2\n    public String createEC2(String script, String tagName, int numberOfInstances) {\n        RunInstancesRequest runRequest = (RunInstancesRequest) RunInstancesRequest.builder()\n                .instanceType(InstanceType.M4_LARGE)\n                .imageId(IMAGE_AMI)\n                .maxCount(numberOfInstances)\n                .minCount(1)\n                .keyName(\"vockey\")\n                .iamInstanceProfile(IamInstanceProfileSpecification.builder().name(\"LabInstanceProfile\").build())\n                .userData(Base64.getEncoder().encodeToString((script).getBytes()))\n                .build();\n\n\n        RunInstancesResponse response = ec2.runInstances(runRequest);\n\n        String instanceId = response.instances().get(0).instanceId();\n\n        Tag tag = Tag.builder()\n                .key(\"Name\")\n                .value(tagName)\n                .build();\n\n        CreateTagsRequest tagRequest = (CreateTagsRequest) CreateTagsRequest.builder()\n                .resources(instanceId)\n                .tags(tag)\n                .build();\n\n        try {\n            ec2.createTags(tagRequest);\n            System.out.printf(\n                    \"[DEBUG] Successfully started EC2 instance %s based on AMI %s\\n\",\n                    instanceId, IMAGE_AMI);\n\n        } catch (Ec2Exception e) {\n            System.err.println(\"[ERROR] \" + e.getMessage());\n            System.exit(1);\n        }\n        return instanceId;\n    }\n\n    public void runInstanceFromAMI(String ami) {\n        RunInstancesRequest runInstancesRequest = RunInstancesRequest.builder()\n                .imageId(ami)\n                .instanceType(InstanceType.T2_MICRO)\n                .minCount(1)\n                .maxCount(5) // todo decide what to put here\n                .build();\n\n        // Launch the instance\n        try {\n            ec2.runInstances(runInstancesRequest);\n        } catch (Ec2Exception e) {\n            System.err.println(\"Failed to launch instance: \" + e.awsErrorDetails().errorMessage());\n        }\n    }\n\n    public RunInstancesResponse runInstanceFromAmiWithScript(String ami, InstanceType instanceType, int min, int max, String script) {\n        RunInstancesRequest runInstancesRequest = RunInstancesRequest.builder()\n                .imageId(ami)\n                .instanceType(instanceType)\n                .minCount(min)\n                .maxCount(max)\n                .userData(Base64.getEncoder().encodeToString(script.getBytes()))\n                // @ADD security features\n                .build();\n\n        // Launch the instance\n        try {\n            return ec2.runInstances(runInstancesRequest);\n        } catch (Ec2Exception e) {\n            System.err.println(\"Failed to launch instance: \" + e.awsErrorDetails().errorMessage());\n            throw new RuntimeException(\"Could not run instance\", e);\n        }\n    }\n\n    public List<Instance> getAllInstances() {\n        DescribeInstancesRequest describeInstancesRequest = DescribeInstancesRequest.builder().build();\n\n        DescribeInstancesResponse describeInstancesResponse = null;\n        try {\n            describeInstancesResponse = ec2.describeInstances(describeInstancesRequest);\n        } catch (Ec2Exception e) {\n            System.err.println(\"Failed to describe instances: \" + e.awsErrorDetails().errorMessage());\n            throw new RuntimeException(\"Could not retrieve instances\", e);\n        }\n\n\n        return describeInstancesResponse.reservations().stream()\n                .flatMap(r -> r.instances().stream())\n                .toList();\n    }\n\n    public List<Instance> getAllInstancesWithLabel(Label label) throws InterruptedException {\n        DescribeInstancesRequest describeInstancesRequest =\n                DescribeInstancesRequest.builder()\n                        .filters(Filter.builder()\n                                .name(\"tag:Label\")\n                                .values(label.toString())\n                                .build())\n                        .build();\n\n        DescribeInstancesResponse describeInstancesResponse = ec2.describeInstances(describeInstancesRequest);\n\n        return describeInstancesResponse.reservations().stream()\n                .flatMap(r -> r.instances().stream())\n                .toList();\n    }\n\n    public List<String> getAllInstanceIdsWithLabel(Label label) throws InterruptedException {\n        DescribeInstancesRequest describeInstancesRequest =\n                DescribeInstancesRequest.builder()\n                        .filters(Filter.builder()\n                                .name(\"tag:Label\")\n                                .values(label.toString())\n                                .build())\n                        .build();\n\n        DescribeInstancesResponse describeInstancesResponse = ec2.describeInstances(describeInstancesRequest);\n\n        return describeInstancesResponse.reservations().stream()\n                .flatMap(r -> r.instances().stream())\n                .map(Instance::instanceId) // Extract only the instance ID\n                .toList();\n    }\n\n\n\n\n    public void terminateInstance(String instanceId) {\n        TerminateInstancesRequest terminateRequest = TerminateInstancesRequest.builder()\n                .instanceIds(instanceId)\n                .build();\n\n        // Terminate the instance\n        try {\n            ec2.terminateInstances(terminateRequest);\n        }  catch (Ec2Exception e) {\n            System.err.println(\"Failed to launch instance: \" + e.awsErrorDetails().errorMessage());\n            throw new RuntimeException(\"Could not run instance\", e);\n        }\n\n        System.out.println(\"Terminated instance: \" + instanceId);\n    }\n\n/*  \n    Questions:\n        - Should we try use 2 regions in order to be able to take advantage of more than 9 ec2 per region?\n        - If so, so we need to make that we allocate an additonal bucket in another region?\n        - Do we need to implement our own constraints in order not to exceed 19 ec2 instances? \n */\n\n\n\n\n    ////////////////////////////// S3\n\n    public String uploadFileToS3(String keyPath, File file) throws Exception {\n        System.out.printf(\"Start upload: %s, to S3\\n\", file.getName());\n\n        PutObjectRequest req =\n                PutObjectRequest.builder()\n\n                        .bucket(bucketName)\n                        .key(keyPath)\n                        .build();\n\n        s3.putObject(req, file.toPath()); // we don't need to check if the file exist already\n        // Return the S3 path of the uploaded file\n        return \"s3://\" + bucketName + \"/\" + keyPath;\n    }\n\n    public String createEmptyFileInS3(String keyPath) throws Exception {\n        PutObjectRequest req =\n                PutObjectRequest.builder()\n\n                        .bucket(bucketName)\n                        .key(keyPath)\n                        .build();\n        return \"s3://\" + bucketName + \"/\" + keyPath;\n    }\n\n    public void downloadFileFromS3(String keyPath, File outputFile) {\n        System.out.println(\"Start downloading file \" + keyPath + \" to \" + outputFile.getPath());\n\n        GetObjectRequest getObjectRequest = GetObjectRequest.builder()\n                .bucket(bucketName)\n                .key(keyPath)\n                .build();\n\n        try {\n            // Retrieve the object as bytes from S3\n            ResponseBytes<GetObjectResponse> objectBytes = s3.getObjectAsBytes(getObjectRequest);\n            byte[] data = objectBytes.asByteArray();\n\n            try (OutputStream os = new FileOutputStream(outputFile)) {\n                os.write(data);\n                System.out.println(\"Successfully downloaded and saved the file from S3.\");\n            }\n        } catch (S3Exception e) {\n            // Handle S3-specific exceptions\n            System.err.println(\"Failed to download file from S3: \" + e.awsErrorDetails().errorMessage());\n            e.printStackTrace();\n        } catch (IOException e) {\n            // Handle file writing errors\n            System.err.println(\"Error writing to file: \" + e.getMessage());\n            e.printStackTrace();\n        } catch (Exception e) {\n            // Catch-all for unexpected exceptions\n            System.err.println(\"Unexpected error occurred: \" + e.getMessage());\n            e.printStackTrace();\n        }\n    }\n\n    public void createBucketIfNotExists(String bucketName) {\n        try {\n            s3.createBucket(CreateBucketRequest\n                    .builder()\n                    .bucket(bucketName)\n                    .createBucketConfiguration(\n                            CreateBucketConfiguration.builder()\n                                    .locationConstraint(BucketLocationConstraint.US_WEST_2)\n                                    .build())\n                    .build());\n            s3.waiter().waitUntilBucketExists(HeadBucketRequest.builder()\n                    .bucket(bucketName)\n                    .build());\n        } catch (S3Exception e) {\n            System.out.println(e.getMessage());\n        }\n    }\n\n    public SdkIterable<S3Object> listObjectsInBucket(String bucketName) {\n        // Build the list objects request\n        ListObjectsV2Request listReq = ListObjectsV2Request.builder()\n                .bucket(bucketName)\n                .maxKeys(1)\n                .build();\n\n        ListObjectsV2Iterable listRes = null;\n        try {\n            listRes = s3.listObjectsV2Paginator(listReq);\n        } catch (S3Exception ignored) {\n        }\n        // Process response pages\n        listRes.stream()\n                .flatMap(r -> r.contents().stream())\n                .forEach(content -> System.out.println(\" Key: \" + content.key() + \" size = \" + content.size()));\n\n        return listRes.contents();\n    }\n\n\n    public List<S3Object> listFilesInS3(String prefix) { //new\n        // Create a request to list objects with the specified prefix\n        ListObjectsV2Request listRequest = ListObjectsV2Request.builder()\n                .bucket(bucketName)\n                .prefix(prefix) // Directory path (e.g., \"responses/inputFileId/\")\n                .build();\n\n        // Execute the request and get the response\n        ListObjectsV2Response listResponse = s3.listObjectsV2(listRequest);\n\n        // Return the list of S3 objects\n        return listResponse.contents();\n    }\n\n    public void deleteEmptyBucket(String bucketName) {\n        DeleteBucketRequest deleteBucketRequest = DeleteBucketRequest.builder().bucket(bucketName).build();\n        try {\n            s3.deleteBucket(deleteBucketRequest);\n        } catch (S3Exception ignored) {\n        }\n    }\n\n    public void deleteAllObjectsFromBucket(String bucketName) {\n        SdkIterable<S3Object> contents = listObjectsInBucket(bucketName);\n\n        Collection<ObjectIdentifier> keys = contents.stream()\n                .map(content ->\n                        ObjectIdentifier.builder()\n                                .key(content.key())\n                                .build())\n                .toList();\n\n        Delete del = Delete.builder().objects(keys).build();\n\n        DeleteObjectsRequest multiObjectDeleteRequest = DeleteObjectsRequest.builder()\n                .bucket(bucketName)\n                .delete(del)\n                .build();\n\n        try {\n            s3.deleteObjects(multiObjectDeleteRequest);\n        } catch (S3Exception ignored) {\n        }\n    }\n\n    public void deleteBucket(String bucketName) {\n        deleteAllObjectsFromBucket(bucketName);\n        deleteEmptyBucket(bucketName);\n    }\n\n    //////////////////////////////////////////////SQS\n\n    /**\n     * @param queueName\n     * @return queueUrl\n     */\n    public String createQueue(String queueName) {\n        CreateQueueRequest request = CreateQueueRequest.builder()\n                .queueName(queueName)\n                .build();\n        CreateQueueResponse create_result = null;\n        try {\n            create_result = sqs.createQueue(request);\n        } catch (SqsException e) {\n            System.err.println(e.awsErrorDetails().errorMessage());\n        }\n\n        assert create_result != null;\n        String queueUrl = create_result.queueUrl();\n        System.out.println(\"Created queue '\" + queueName + \"', queue URL: \" + queueUrl);\n        return queueUrl;\n    }\n\n    public void deleteQueue(String queueUrl) {\n        DeleteQueueRequest req =\n                DeleteQueueRequest.builder()\n                        .queueUrl(queueUrl)\n                        .build();\n\n        try {\n            sqs.deleteQueue(req);\n        } catch (SqsException e) {\n            System.err.println(e.awsErrorDetails().errorMessage());\n        }\n    }\n\n    public String getQueueUrl(String queueName) {\n        GetQueueUrlRequest getQueueRequest = GetQueueUrlRequest.builder()\n                .queueName(queueName)\n                .build();\n        String queueUrl = null;\n        try {\n            queueUrl = sqs.getQueueUrl(getQueueRequest).queueUrl();\n        } catch (SqsException e) {\n            System.err.println(e.awsErrorDetails().errorMessage());\n        }\n        System.out.println(\"Queue URL: \" + queueUrl);\n        return queueUrl;\n    }\n\n    public int getQueueSize(String queueUrl) {\n        GetQueueAttributesRequest getQueueAttributesRequest = GetQueueAttributesRequest.builder()\n                .queueUrl(queueUrl)\n                .attributeNames(\n                        QueueAttributeName.APPROXIMATE_NUMBER_OF_MESSAGES,\n                        QueueAttributeName.APPROXIMATE_NUMBER_OF_MESSAGES_NOT_VISIBLE,\n                        QueueAttributeName.APPROXIMATE_NUMBER_OF_MESSAGES_DELAYED\n                )\n                .build();\n\n        GetQueueAttributesResponse queueAttributesResponse = null;\n        try {\n            queueAttributesResponse = sqs.getQueueAttributes(getQueueAttributesRequest);\n        } catch (SqsException e) {\n            System.err.println(e.awsErrorDetails().errorMessage());\n        }\n        Map<QueueAttributeName, String> attributes = queueAttributesResponse.attributes();\n\n        return Integer.parseInt(attributes.get(QueueAttributeName.APPROXIMATE_NUMBER_OF_MESSAGES)) +\n                Integer.parseInt(attributes.get(QueueAttributeName.APPROXIMATE_NUMBER_OF_MESSAGES_NOT_VISIBLE)) +\n                Integer.parseInt(attributes.get(QueueAttributeName.APPROXIMATE_NUMBER_OF_MESSAGES_DELAYED));\n    }\n\n\n    public String sendMessage(String queueUrl, String messageBody) {\n        SendMessageRequest sendMessageRequest = SendMessageRequest.builder()\n                .queueUrl(queueUrl)\n                .messageBody(messageBody)\n                .build();\n\n        SendMessageResponse sendMessageResponse = sqs.sendMessage(sendMessageRequest);\n        String messageId = sendMessageResponse.messageId();\n        return messageId;\n    }\n\n    public String sendMessageWithId(String queueUrl, String messageBody, String fileId) {\n        MessageAttributeValue fileIdAttribute = MessageAttributeValue.builder()\n                .stringValue(fileId)\n                .dataType(\"String\")\n                .build();\n\n        SendMessageRequest sendMessageRequest = SendMessageRequest.builder()\n                .queueUrl(queueUrl)\n                .messageBody(messageBody)\n                .messageAttributes(Map.of(\"FileId\", fileIdAttribute)) // Add the fileId attribute\n                .build();\n\n        SendMessageResponse sendMessageResponse = sqs.sendMessage(sendMessageRequest);\n\n        String messageId = sendMessageResponse.messageId();\n        System.out.println(\"Message sent with MessageId: \" + messageId + \" and FileId: \" + fileId);\n        return messageId;\n    }\n\n\n\n\n\n//    public void sendMessageBatches(String queueUrl, List<String> messages, String messageId) { // check if needs to be synchronized\n//\n//        Iterator<String> msgIter = messages.iterator();\n//        while (msgIter.hasNext()) {\n//            List<SendMessageBatchRequestEntry> entries = new ArrayList<>();\n//\n//            // create batches of 10 entries (aws limitations)\n//            for (int i = 1; msgIter.hasNext() && i <= 10; i++ ) {\n//                entries.add(new SendMessageBatchRequestEntry(\"msg_\" + i, msgIter.next()));\n//            }\n//\n//            SendMessageBatchRequest batchRequest = new SendMessageBatchRequest()\n//                .withQueueUrl(queueUrl)\n//                .withEntries(entries);\n//\n//            // send batch\n//            sqs.sendMessageBatch(batchRequest);\n//        }\n//    }\n\n\n    public List<Message> receiveMessages(String queueUrl) {\n        // Build the ReceiveMessageRequest\n        ReceiveMessageRequest receiveMessageRequest = ReceiveMessageRequest.builder()\n                .queueUrl(queueUrl)\n                .maxNumberOfMessages(10)\n                .waitTimeSeconds(20)\n                .build();\n\n        // Use the SQS client to receive messages\n        return sqs.receiveMessage(receiveMessageRequest).messages();\n    }\n\n\n    public Message receiveMessageWithId(String queueUrl, String appFileId) {\n        // Build the ReceiveMessageRequest\n        ReceiveMessageRequest receiveMessageRequest = ReceiveMessageRequest.builder()\n                .queueUrl(queueUrl)\n                .maxNumberOfMessages(1) // Fetch one message at a time\n                .waitTimeSeconds(10)\n                .messageAttributeNames(\"All\") // Include all message attributes\n                .build();\n\n        ReceiveMessageResponse receiveMessageResponse = sqs.receiveMessage(receiveMessageRequest);\n        List<Message> messages = receiveMessageResponse.messages();\n\n        if (messages.isEmpty()) {\n            System.out.println(\"No messages available.\");\n            return null;\n        }\n\n        Message message = messages.get(0);\n\n        String fileId = message.messageAttributes().getOrDefault(\"FileId\", null) != null\n                ? message.messageAttributes().get(\"FileId\").stringValue()\n                : null;\n\n        if (fileId != null && fileId.equals(appFileId)) {\n            System.out.println(\"Processing message: \" + message.body());\n            sqs.deleteMessage(DeleteMessageRequest.builder()\n                    .queueUrl(queueUrl)\n                    .receiptHandle(message.receiptHandle())\n                    .build());\n            return message;\n        } else {\n            System.out.println(\"Returning message to the queue. FileId: \" + fileId);\n            sqs.changeMessageVisibility(ChangeMessageVisibilityRequest.builder()\n                    .queueUrl(queueUrl)\n                    .receiptHandle(message.receiptHandle())\n                    .visibilityTimeout(0)\n                    .build());\n            return null;\n        }\n    }\n\n\n\n\n    public void deleteMessages(String queueUrl, List<Message> messages) {\n        for (Message m : messages) {\n            sqs.deleteMessage(DeleteMessageRequest.builder()\n                    .queueUrl(queueUrl)\n                    .receiptHandle(m.receiptHandle()) // Correct method for SDK v2\n                    .build());\n        }\n    }\n\n    public void deleteMessage(String queueUrl, Message message) {\n        sqs.deleteMessage(DeleteMessageRequest.builder()\n                .queueUrl(queueUrl)\n                .receiptHandle(message.receiptHandle()) // Correct method for SDK v2\n                .build());\n    }\n\n    public int getSummaryLimit(){\n        return summaryLimit;\n    }\n\n    public String getBucketName(){\n        return bucketName;\n    }\n\n\n\n    ///////////////////////\n\n    public enum Label {\n        Manager,\n        Worker\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Local-App/src/main/java/AWS.java b/Local-App/src/main/java/AWS.java
--- a/Local-App/src/main/java/AWS.java	(revision cc9a4560f3186c9a240bf6a014f37c4839206ddb)
+++ b/Local-App/src/main/java/AWS.java	(date 1732996594733)
@@ -193,11 +193,11 @@
         System.out.println("Terminated instance: " + instanceId);
     }
 
-/*  
+/*
     Questions:
         - Should we try use 2 regions in order to be able to take advantage of more than 9 ec2 per region?
         - If so, so we need to make that we allocate an additonal bucket in another region?
-        - Do we need to implement our own constraints in order not to exceed 19 ec2 instances? 
+        - Do we need to implement our own constraints in order not to exceed 19 ec2 instances?
  */
 
 
